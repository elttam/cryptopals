package com.cryptopals;

import com.cryptopals.set_8.GCM;
import com.cryptopals.set_8.PolynomialGaloisFieldOverGF2;
import com.cryptopals.set_8.PolynomialRing2;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.xml.bind.DatatypeConverter;

public class Exploit {
    private List<PolynomialGaloisFieldOverGF2.FieldElement> candidateAuthenticationKeys;
    public boolean debugEnabled = false;
    
    public void debug(String s) {
        if (debugEnabled) {
            System.out.println(s);
        }
    }
    
    public void recoverKeys(String cTxt1Hex, String cTxt2Hex) {
        byte[] assocData = new byte[0];
        byte[] cTxt1 = DatatypeConverter.parseHexBinary(cTxt1Hex);
        byte[] cTxt2 = DatatypeConverter.parseHexBinary(cTxt2Hex);

        PolynomialRing2<PolynomialGaloisFieldOverGF2.FieldElement> poly1 = GCM.toPolynomialRing2(cTxt1, assocData),
                                                                   poly2 = GCM.toPolynomialRing2(cTxt2, assocData),
                                                                   equation = poly1.add(poly2).toMonicPolynomial();
        debug("cTxt1 polynomial: " + poly1);
        debug("cTxt2 polynomial: " + poly2);
        debug("Equation: " + equation);

        List<PolynomialRing2<PolynomialGaloisFieldOverGF2.FieldElement>>
            allFactors = equation.squareFreeFactorization().stream().map(PolynomialRing2.PolynomialAndPower::getFactor)
                .flatMap(x -> x.distinctDegreeFactorization().stream()).collect(Collectors.toList()),

            oneDegreeFactors = allFactors.stream().filter(x -> x.intDegree() == 1).collect(Collectors.toList()),

            oneDegreeFactorsThroughEdf = allFactors.stream().filter(x -> x.intDegree() > 1)
                .flatMap(x -> x.equalDegreeFactorization(1).stream()).collect(Collectors.toList());

        debug("Candidates found after square-free and distinct-degree factorization: " + oneDegreeFactors);
        debug("Additional candidates found after equal-degree factorization: " + oneDegreeFactorsThroughEdf);

        oneDegreeFactors.addAll(oneDegreeFactorsThroughEdf);
        candidateAuthenticationKeys = oneDegreeFactors.stream().map(x -> x.getCoef(0)).collect(Collectors.toList());

        debug("-> Recovered candidates: " +
                candidateAuthenticationKeys.stream().map(c -> c.toString()).collect((Collectors.joining(", "))));
    }

    public void forgeTag(String knownCtxtHex, String chosenCtxtHex) {
        byte[] knownCtxt = DatatypeConverter.parseHexBinary(knownCtxtHex);
        byte[] chosenCtxt = DatatypeConverter.parseHexBinary(chosenCtxtHex);
        List<String> forgedList = new ArrayList<>();
        
        for (PolynomialGaloisFieldOverGF2.FieldElement candidateAuthenticationKey : candidateAuthenticationKeys) {    
            System.out.println("-> Using authentication key: " + candidateAuthenticationKey);
            String forgedCtxtHex = GCM.forgeCipherText(knownCtxt, chosenCtxt, candidateAuthenticationKey);
            
            if (forgedList.contains(forgedCtxtHex)) {
                System.out.println("Forged tag is identical, skipping duplicate");
                continue;
            } else {
                forgedList.add(forgedCtxtHex);
            }
            
            System.out.print("Legit  cipher text: " + knownCtxtHex + " = "); printBlocks(knownCtxtHex);
            System.out.print("Forged cipher text: " + forgedCtxtHex + " = "); printBlocks(forgedCtxtHex);
        }
    }

    public static void verifyForged(String forged, String key) {
        try {
            Crypto c = new Crypto(key);
            String pt = c.decrypt(forged);
            System.out.println("OK: " + pt);
        } catch (GeneralSecurityException ex) {
            Logger.getLogger(Exploit.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    public static void printBlocks(String ctHex) {
        int BLOCK_SIZE = 16;
        boolean hasTag = true;
        byte[] tag = new byte[0];
        byte[] ct = DatatypeConverter.parseHexBinary(ctHex);
        
        if (hasTag) {
            tag = Arrays.copyOfRange(ct, ct.length - BLOCK_SIZE, ct.length);
            ct = Arrays.copyOfRange(ct, 0, ct.length - BLOCK_SIZE);
        }
        
        int numBlocks = ct.length / BLOCK_SIZE + 1;
        //System.out.println("numBlocks: " + numBlocks);

        for (int i = 0; i < numBlocks; i++) {
            byte[] tmp = Arrays.copyOfRange(ct, i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE);
            System.out.print(DatatypeConverter.printHexBinary(tmp));
            System.out.print(" ");
        }

        if (hasTag) {
            System.out.println(DatatypeConverter.printHexBinary(tag));
        }
    }
    
    public static String xor(String s1, String s2) {
        byte[] b1 = DatatypeConverter.parseHexBinary(s1), b2 = DatatypeConverter.parseHexBinary(s2);
        byte[] b3 = new byte[b1.length];
        for (int i = 0; i < b1.length; i++) {
            b3[i] = (byte) (b1[i] ^ b2[i]);
        }
        return DatatypeConverter.printHexBinary(b3);
    }
    
    public static String decode(String s) {
        String r = s.replace(" ", "");
        boolean isB64 = r.matches(".*[G-Zg-z=-].*");
        if (isB64) {
            return DatatypeConverter.printHexBinary(Base64.getUrlDecoder().decode(r));
        } else {
            return r;
        }
    }
    
    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println("usage error");
            System.exit(2);
            
        } else if (args.length == 1) {
            String forged = decode(args[0]);
            Exploit.verifyForged(forged, "YELLOW_SUBMARINE");

        } else if (args.length > 1) {
            String cTxt1Hex = decode(args[0]), cTxt2Hex = decode(args[1]);

            if (args.length == 2) {
                System.out.println("[+] Pretty printing");
                System.out.print("cTxt1: ");
                printBlocks(cTxt1Hex);
                
                System.out.print("cTxt2: ");
                printBlocks(cTxt2Hex);
                
                System.out.print("XORed: ");
                printBlocks(Exploit.xor(cTxt1Hex, cTxt2Hex));

                System.out.println("[+] Recovering candidate authentication keys");
                Exploit exp = new Exploit();
                exp.debugEnabled = true;
                exp.recoverKeys(cTxt1Hex, cTxt2Hex);
                
            } else {
                String cTxt3Hex = args[2];
                System.out.println("[+] Forging ciphertext " + cTxt3Hex);
                Exploit exp = new Exploit();
                exp.recoverKeys(cTxt1Hex, cTxt2Hex);
                exp.forgeTag(cTxt1Hex, cTxt3Hex);                                
            }
        }
    }
}
